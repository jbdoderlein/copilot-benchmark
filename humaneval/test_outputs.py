"""
Test outpus from HumanEval based prompts generated by Codex and Copilot
"""
import argparse
import json
import os
from pathlib import Path
import epicbox

epicbox.configure(
    profiles=[
        epicbox.Profile('python', 'python:alpine'),
    ]
)

def run_in_docker(file):
    """Execute code in epicbox docker"""
    limits = {'cputime': 5, 'memory': 128}
    files = [file]
    return epicbox.run(
        'python', f"python3 {file['name']}",
        files=files,
        limits=limits,
    )



if '__main__' in __name__:
    parser = argparse.ArgumentParser(description='Generate solution from copilot/codex and test')
    parser.add_argument('directory', type=str,
                        help='Sample directory')
    parser.add_argument('-e', '--engine', type=str, nargs='+', default=[
        'copilot', 'codex', 'codex_100'])
    parser.add_argument('-t', '--temperature', type=float, nargs='+', default=[0.0,0.2,0.4,0.6,0.8,1.0])

    args = parser.parse_args()
    lib_path = args.directory
    engines = args.engine
    temperatures = args.temperature

    engine_category = {
        'one_shot': ['copilot', 'codex'],
        'multi_shot': ['codex_100']
    }

    PROMPT_PATH = "prompts"
    OUTPUT_PATH = "outputs"
    TEST_PATH = "tests"
    RESULT_PATH = "results"

    for temperature in temperatures:
        for engine in engines:
            Path(
                os.path.join(RESULT_PATH, str(temperature), engine)
            ).mkdir(parents=True, exist_ok=True)

    for temperature in temperatures:
        for engine in engines:
            output_dir_path = os.path.join(OUTPUT_PATH, str(temperature), engine, lib_path)
            result_dir_path = os.path.join(RESULT_PATH, str(temperature), engine)
            if not os.path.exists(os.path.join(result_dir_path, (lib_path+".json"))):
                if engine in engine_category['one_shot']:
                    results = {}
                    print(f"Generating {engine} solution")
                    for i, f in enumerate(os.listdir(output_dir_path)):
                        print(f"({i+1}/164) : {f}", end="", flush=True)
                        if os.path.isfile(os.path.join(output_dir_path , f)):
                            with open(os.path.join(output_dir_path , f), 'r') as output_file:
                                content = output_file.read()

                            res = run_in_docker({
                                'name': f,
                                'content': content.encode('utf-8')
                            })

                            results[f] = {
                                'success': res['exit_code']==0,
                                'first': 1 if res['exit_code']==0 else 0,
                                'total': 1 if res['exit_code']==0 else 0
                            }
                            print(" Done", flush=True)
                        else:
                            print(" Skipped", flush=True)
                    with open(os.path.join(result_dir_path, (lib_path+".json")), 'w') as f:
                        json.dump(results, f)

                elif engine in engine_category['multi_shot']:
                    results = {}
                    print(f"Generating {engine} solution")
                    N = engine.split('_')[-1]
                    for i, f in enumerate(os.listdir(output_dir_path)):
                        print(f"({i+1}/164) : {f}", flush=True)
                        if os.path.isdir(os.path.join(output_dir_path , f.replace(".py", ""))):
                            for j, subf in enumerate(os.listdir(os.path.join(output_dir_path, f.replace(".py", "")))):
                                print(f"\r({j+1}/{N})", end="", flush=True)
                                with open(os.path.join(output_dir_path, f.replace(".py", "") , subf), 'r') as output_file:
                                    content =  output_file.read()
                                    res = run_in_docker({
                                        'name': f,
                                        'content': content.encode('utf-8')
                                    })
                                    if f not in results:
                                        results[f] = {
                                            'first': 0,
                                            'total': 0
                                        }
                                    if res['exit_code']==0:
                                        results[f]['total'] += 1
                                        if results[f]['first'] == 0:
                                            results[f]['first'] = j+1
                            results[f]['success'] = results[f]['first'] != 0
                            print(" Done", flush=True)
                        else:
                            print(" Skipped", flush=True)
                    with open(os.path.join(result_dir_path, (lib_path+".json")), 'w') as f:
                        json.dump(results, f)
            else:
                print(f"{lib_path}({temperature}, {engine}) already generated")
                continue
